#include<iostream>
//#include<cmath>
#include<fstream>

struct complex { // base class 
private:
	double x; // real part
	double y; // imaginary part
public:
	complex(int x = 0, int y = 0) : x(x), y(y) {} // constructor
	complex(const complex& Complex) : x(Complex.x), y(Complex.y) {} // copy constructor
	~complex() {} // destructor
	void print() // operator of printing everything
	{
		print_normal_form();
		print_exponential_form();
	}
	void print_normal_form() // simply printing coordinates
	{
		std::cout << x << "+ i*" << y << std::endl;
	}


	complex operator=(const complex& complex)
	{
		this->x = complex.x;
		this->y = complex.y;
		return *this;
	};
	complex operator+(const complex& plus)
	{
		complex res(this->x + plus.x, this->y + plus.y);
		return res;
	};
	complex operator*(const complex& mult)
	{
		complex res(this->x * mult.x, this->y * mult.y);
		return res;
	}; 
	complex operator/(const complex& divide)
	{
		complex res(this->x / divide.x, this->y / divide.y);
		return res;
	};
	complex operator-(const complex& Complex)
	{
		complex res(this->x - Complex.x, this->y - Complex.y);
		return res;
	};
	complex conj(const complex& Complex) // conjuction
	{
		complex res(this->x + Complex.x, -this->y - Complex.y);
		return res;
	};
	/*
	complex operator|(const complex& Complex) // absolute value
	{
		complex res(this->x + this->y + Complex.x + Complex.y);
		return res;
	}; */
	double arg()
	{
		return atan2(x, y);
	};

	void print_exponential_form()
	{
		std::cout << "e" << "^i" << arg() << std::endl; // e^i*angle
	}

	double abs()
	{
		return x + y;
	};
	friend complex operator+(const complex& double, const complex& plus)
	{
		complex res(double.x + complex.x, plus.y + complex.y);
		return res;
	};
	friend complex operator-(double, complex)
	{
		complex res(plus.x - complex.x, plus.y - complex.y);
		return res;
	};
	friend complex operator*(double, complex)
	{
		complex res(plus.x * complex.x, plus.y * complex.y);
		return res;
	};
	friend complex operator/(double, complex)
	{
		complex res(plus.x / complex.x, plus.y / complex.y);
		return res;
	};
};





void print(complex& sh)
{
	sh.print_normal_form();
	sh.print_exponential_form();
}


int main()
{
	
	return EXIT_SUCCESS;
}


/*
struct doublex : complex
{
	int double_x;
	doublex(int x = 0) : x(x), x(x) {} // constructor
	doublex(const complex& shape) : x(shape.x), x(shape.x) {} // copy constructor
	~doublex() {} // destructor
	doublex(int x) : double_x(x)
	{
		return double_x::double_x(x);
	};

}
*/
