#include<iostream>
//#include<cmath>
#include<fstream>

struct complex { // base class 
private:
	double x; // real part
	double y; // imaginary part
public:
	complex(int x = 0, int y = 0) : x(x), y(y) {} // constructor
	complex(const complex& Complex) : x(Complex.x), y(Complex.y) {} // copy constructor
	~complex() {} // destructor
	void print() // operator of printing everything
	{
		print_normal_form();
		print_exponential_form();
	}
	void print_normal_form() // simply printing coordinates
	{
		std::cout << x << "+ i*" << y << std::endl;
	}


	complex operator=(const complex& complex)
	{
		this->x = complex.x;
		this->y = complex.y;
		return *this;
	};
	complex operator+(const complex& plus)
	{
		complex res(this->x + plus.x, this->y + plus.y);
		return res;
	};
	complex operator*(const complex& mult)
	{
		complex res(this->x * mult.x, this->y * mult.y);
		return res;
	}; 
	complex operator/(const complex& divide)
	{
		complex res(this->x / divide.x, this->y / divide.y);
		return res;
	};
	complex operator-(const complex& Complex)
	{
		complex res(this->x - Complex.x, this->y - Complex.y);
		return res;
	};
	complex conj(const complex& Complex) // conjuction
	{
		complex res(this->x + Complex.x, -this->y - Complex.y);
		return res;
	};
	/*
	complex operator|(const complex& Complex) // absolute value
	{
		complex res(this->x + this->y + Complex.x + Complex.y);
		return res;
	}; */
	double arg()
	{
		return atan2(x, y);
	};

	void print_exponential_form()
	{
		std::cout << "e" << "^i" << arg() << std::endl; // e^i*angle
	}

	double abs()
	{
		return x + y;
	};
	friend complex operator+(const complex& double, const complex& plus)
	{
		complex res(double.x + complex.x, plus.y + complex.y);
		return res;
	};
	friend complex operator-(double, complex)
	{
		complex res(plus.x - complex.x, plus.y - complex.y);
		return res;
	};
	friend complex operator*(double, complex)
	{
		complex res(plus.x * complex.x, plus.y * complex.y);
		return res;
	};
	friend complex operator/(double, complex)
	{
		complex res(plus.x / complex.x, plus.y / complex.y);
		return res;
	};
};





void print(complex& sh)
{
	sh.print_normal_form();
	sh.print_exponential_form();
}


int main()
{
	
	return EXIT_SUCCESS;
}


/*
struct doublex : complex
{
	int double_x;
	doublex(int x = 0) : x(x), x(x) {} // constructor
	doublex(const complex& shape) : x(shape.x), x(shape.x) {} // copy constructor
	~doublex() {} // destructor
	doublex(int x) : double_x(x)
	{
		return double_x::double_x(x);
	};

}
*/

/*
struct Circle : public Shape { // deriving class
	int r;
	Circle(int x = 0, int y = 0, int r = 0) : // x,y - posiition; r - radius
		Shape(x, y), r(r) {}
	void printName() override // override is necessary for application of virtual classes
	{
		std::cout << "CIRCLE ";
	}
	void printSquare() override
	{
		std::cout << " S = " << 3.1415926535 * r * r << std::endl;
	}
};

struct Square : public Shape { // driving class
	int a;
	Square(int x = 0, int y = 0, int a = 0):
		Shape(x, y), a(a) {}
	void printName() override
	{
		std::cout << "SQUARE ";
	}
	void printSquare() override
	{
		std::cout << " S = " << a * a << std::endl;
	}

};



//srand(time(0));
	Shape** shapes = new Shape * [3]; //dynamic array with 10 elems
	for (int i = 0; i < 3; ++i)
	{
		int xx = rand() % 100;
		int yy = rand() % 100;
		int p = rand() % 100;
		if (rand() % 2 == 0)
		{
			shapes[i] = new Circle(xx, yy, p);
		}
		else
		{
			shapes[i] = new Square(xx, yy, p);
		}
	}

	for (int i = 0; i < 3; ++i)
	{
		shapes[i]->print();
	}

	for (int i = 0; i < 10; ++i) // clearing the memory
	{
		delete shapes[i];
	}
	delete[] shapes;

*/
